import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;

import javaslang.collection.Array;
import javaslang.collection.HashMap;
import javaslang.collection.Set;

/*
 * This Java source file was generated by the Gradle 'init' task.
 */
public class App {
    private static final String OUTPUT = "resources/res.out";
	private static final String INPUT = "resources/trending_today.in";
	private static int[] videos;
	private static Endpoint[] endpoints;
	private static Cache[] caches;
	private static Request[] requests;
	private static int cacheCapacity;

    public static void main(String[] args) throws IOException {
        readInput();
        readOutput();

        System.out.println(computeScore());
    }

	private static long computeScore() {
		long totalSaved = 0L;
		long totalRequests = 0L;
		for (Request request: requests) {
			Endpoint endpoint = endpoints[request.endpoint];
			totalSaved += request.count *
				(endpoint.cacheLatencies.filter((cacheTuple) ->
					caches[cacheTuple._1.id].videos.contains(request.video)).toArray().sortBy(cacheTuple -> 
						cacheTuple._2).reverse()
				.headOption()
				.map(cacheTuple -> endpoint.dcLatency - cacheTuple._2).getOrElse(0));
			totalRequests += request.count;
		}
		
		totalSaved *= 1000;
		return totalSaved / totalRequests;
	}

	private static void readOutput() throws IOException {
		Array<String> output = Array.ofAll(Files.readAllLines(Paths.get(OUTPUT)));
		for (int i = 1; i < output.size(); i++) {
			Array<String> cacheLine = Array.of(output.get(i).split(" "));
			int cacheId = Integer.parseInt(cacheLine.head());
			Set<Integer> cachedVideos = cacheLine.tail().map(Integer::parseInt).toSet();
			caches[cacheId] = new Cache(cacheId);
			caches[cacheId].videos = cachedVideos;
		}
		
	}

	private static void readInput() throws IOException {
		Array<String> input = Array.ofAll(Files.readAllLines(Paths.get(INPUT)));

		String[] firstLine = input.get(0).split(" ");
		videos = new int[Integer.parseInt(firstLine[0])];
		endpoints = new Endpoint[Integer.parseInt(firstLine[1])];
		requests = new Request[Integer.parseInt(firstLine[2])];
		caches = new Cache[Integer.parseInt(firstLine[3])];
		cacheCapacity = Integer.parseInt(firstLine[4]);
		
		String[] videosLine = input.get(1).split(" ");
		for (int i = 0; i < videosLine.length; i++) 
			videos[i] = Integer.parseInt(videosLine[i]);
		
		for (int i = 0; i < caches.length; i++)
			caches[i] = new Cache(i);
		
		int lastLine = parseEndpoints(input);
		parseRequests(input, lastLine);
		System.out.println("parsed input");
	}

	private static void parseRequests(Array<String> input, int lastLine) {
		for (int i = 0; i < requests.length; i++) {
			String[] requestLine = input.get(i + lastLine).split(" ");
            Request request = new Request(Integer.parseInt(requestLine[0]), Integer.parseInt(requestLine[1]), Integer.parseInt(requestLine[2]));
            requests[i] = request;
            endpoints[request.endpoint].requests = endpoints[request.endpoint].requests.append(request);
		}
	}

	private static int parseEndpoints(Array<String> input) {
		int currentLine = 2;
		for (int i = 0; i < endpoints.length; i++) {
			String[] firstEndpointLine = input.get(currentLine++).split(" ");
			endpoints[i] = new Endpoint(i);
			endpoints[i].dcLatency = Integer.parseInt(firstEndpointLine[0]);
			int cacheCount = Integer.parseInt(firstEndpointLine[1]);
			
			java.util.Map<Cache, Integer> cacheLatencies = new java.util.HashMap<>();
			for (int j = 0; j < cacheCount; j++) {
				cacheLatencies = new java.util.HashMap<>();
				String[] cacheEndpointLine = input.get(currentLine++).split(" ");
				Cache cache = caches[Integer.parseInt(cacheEndpointLine[0])];
				int latency = Integer.parseInt(cacheEndpointLine[1]);
				cacheLatencies.put(cache, latency);
				cache.jlat.put(endpoints[i], latency);
				if (currentLine % 1000 == 0)
					System.out.println("parsed: " + currentLine);
			}
			endpoints[i].cacheLatencies = HashMap.ofAll(cacheLatencies);
		}
		
		for (int j = 0; j < caches.length; j++)
			caches[j].endpointLatencies = HashMap.ofAll(caches[j].jlat);
		
		return currentLine;
	}

}
